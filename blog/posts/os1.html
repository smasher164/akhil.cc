<p><style>
	p {
		white-space: pre-wrap;
	}
</style>
</p><h1> Notes on OS Construction: Booting (WIP)</h1><h4> September 30, 2019</h4><p>	When a computer is turned on, special firmware that is stored in non-volalite memory is run. The two most popular kinds are BIOS and UEFI-based firmware. The original BIOS (Basic Input/Output System) firmware was created for the IBM PC in the 70s. Since there was no official spec, PCs since then have conformed to match its behavior.

	The BIOS's goal is to iterate through all of the attached media until it can successfully boot from one. At start-up, the CPU executes the BIOS program, and on x86 chips this will happen in 16-bit mode. During boot, the BIOS loads the first block from disk, called the Master Boot Record (MBR), which contains bootstrapping code, a partition table, and the disk signature. The MBR is 512 bytes and is loaded into the physical address 0x7C00. Why? <a href="https://www.glamenv-septzen.net/en/view/6">Apparently</a>, this was a conscious decision by the IBM PC 5150 development team to leave surrounding memory available for interrupt vectors, the BIOS, and the OS. The BIOS checks that the signature matches 0xAA55 and proceeds to execute the boostrapping code.

	Bootloaders will often run in multiple stages, to access more program memory. The bootstrapping code in the MBR will usually load another block corresponding to the Volume Boot Record (VBR), which is located in a separate partition that is found by scanning the MBR's partition table. Eventually the loader will want to enter protected mode, with access to a larger address space and 32-bit registers.

	This process involves setting up the Global Descriptor Table (GDT), setting up the Interrupt Descriptor Table (IDT), and enabling the A20 Line. Real mode uses segmented addressing, where two segment registers can store a logical address composed of a 16-bit base and 16-bit offset. Its 20-bit physical address is computed as <code>(base&lt;&lt;4) + offset</code>. Protected mode uses descriptors to translate logical addresses to physical addresses.

	The GDT contains 8-byte entries, each of which has a base address, segment length, and other configurable attributes like access permissions. Indexes into the GDT are called selectors. Every GDT is required to have its first descriptor be <strong><code>NULL</code></strong>. By initializing unused segments with this entry, an exception is triggered when unused segments are referenced. The GDT can be loaded with the <code>LGDT</code> instruction.

	Interrupts are a way to notify the CPU about an event, and have it execute some code. In real mode, a table of interrupt handlers is loaded and reserved between the physical addresses 0x0000 and 0x03FF, where each pointer is 4 bytes. These range from division-by-zero to <a href="https://en.wikipedia.org/wiki/BIOS_interrupt_call">BIOS interrupts</a> that can write to the screen. Entering protected will require disabling interrupts beforehand. In protected mode, there is no predefined table, and BIOS interrupts are no longer accessible.

	An IDT needs to be set up, also an array of descriptors, each of which has a selector into the GDT for the code segment where the interrupt handler is located, an offset to the specific interrupt handler, and configurable attributes like its privilege level and gate type. Gate types include the task gate (to indicate a task switch and save context), trap gate (to call an interrupt handler), and interrupt gate (to disable interrupts when the handler is executed). The IDT can be loaded with the <code>LIDT</code> instruction.

<strong><em>TODO</em></strong><em>: Display Segment Descriptor Layouts</em>

	In order to address up to 4GB of memory, the 21st (index from zero) address line must be explicitly be enabled. Why isn't this enabled by default? Before processors with more than 20 address lines were introduced, accessing an address past 1MB would wrap around. Some engineers depended on this behavior, so in effort to stay backwards compatible, the 21st address line (A20 line) must be explicitly turned on. There are many ways of turning on the A20 line, all of which are required to have the widest processor support. 

	Finally, set the Protection Enable (PE) bit in CR0, a control register. Perform a jump to a far address to clear the prefetch queue, and initialize protected mode. This will involve initializing the segment registers with a data segment from the GDT, re-enabling interrupts, and jumping to the kernel.

	<em>NOTE: There is an additional process when entering long mode, a.k.a 64-bit mode, which involves CPU feature detection, disabling and re-enabling interrupts, setting up paging, setting the long mode bit in the model-specific-register, and updating the GDT and IDT.</em>

</p>